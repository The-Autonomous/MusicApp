<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
        <title>Music Control Panel</title>
        <style>
            *, *::before, *::after {
                box-sizing: border-box;
            }

            body {
                margin: 0;
                padding: 0;
                font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
                background: linear-gradient(135deg, #0f2027, #203a43, #2c5364);
                color: #fff;
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: center;
                min-height: 100vh;
                overflow-x: hidden; /* Prevent scrollbar from appearing due to gradient */
            }

            .container {
                background: rgba(255, 255, 255, 0.05);
                backdrop-filter: blur(10px);
                padding: 2.5rem; /* Increased padding for more breathing room */
                border-radius: 20px;
                box-shadow: 0 20px 40px rgba(0, 0, 0, 0.4);
                text-align: center;
                width: 90%;
                max-width: 550px; /* Slightly wider */
                border: 1px solid rgba(255, 255, 255, 0.1); /* Subtle border */   
                position: relative; /* Essential for positioning children relative to the container */
                overflow: visible; /* Allow content to overflow if needed, or adjust padding */
            }

            @media (max-width: 600px) {
                .container {
                    border-radius: 0;
                    height: 100%;
                    width: 100%;
                    top: 0;
                    left: 0;
                }
            }

            h1 {
                font-size: 1.8rem; /* Larger heading */
                margin-bottom: 1.2rem;
                letter-spacing: 1px;
                text-shadow: 0 0 10px rgba(255, 255, 255, 0.2);
            }

            .song-title {
                margin-bottom: 1rem;
                font-size: 1.4rem; /* Larger song title */
                font-weight: bold;
                min-height: 1.4em; /* Prevent layout shift if content is short */
            }
            
            .volume-display {
                margin-bottom: 2rem; /* More space below volume */
                font-size: 1.1rem;
                opacity: 0.85;
            }
            
            .paused {
                color: #f39c12; /* Orange for paused */
                font-weight: bold;
            }

            .repeat-active {
                color: #3498db; /* Blue for repeat */
                font-weight: bold;
            }
            
            .buttons {
                display: grid; /* Use CSS Grid for better control */
                grid-template-columns: repeat(3, 1fr); /* 3 columns for main controls */
                gap: 1.2rem; /* Increased gap between buttons */
                justify-content: center;
                align-items: center;
            }
            
            button {
                background: #1abc9c;
                border: none;
                border-radius: 50px;
                padding: 1.1rem 0.8rem; /* More vertical padding */
                font-size: 1.05rem; /* Slightly larger font */
                color: white;
                font-weight: bold;
                cursor: pointer;
                transition: all 0.3s ease;
                min-width: 100px;
                box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2); /* Button shadow */
                letter-spacing: 0.5px;
            }

            button:hover {
                background: #16a085;
                transform: translateY(-3px); /* Lift effect on hover */
                box-shadow: 0 8px 20px rgba(0, 0, 0, 0.3);
            }

            /* Specific styling for play/pause button for prominence */
            button[data-action="pause"], button[data-action="play"] {
                grid-column: 2; /* Center in the middle column */
                background: #e74c3c; /* Red for play/pause */
                font-size: 1.2rem;
                padding: 1.2rem 1rem;
            }

            button[data-action="pause"]:hover, button[data-action="play"]:hover {
                background: #c0392b;
            }

            /* Make volume and repeat buttons fill full width on smaller screens, stacked */
            @media (max-width: 600px) {
                .buttons {
                    grid-template-columns: 1fr 1fr; /* 2 columns on smaller screens */
                    gap: 1rem;
                }
                button[data-action="pause"], button[data-action="play"] {
                    grid-column: span 2; /* Make play/pause span two columns */
                    order: -1; /* Move it to the top */
                }
            }

            @media (max-width: 480px) {
                .buttons {
                    grid-template-columns: 1fr; /* Single column on very small screens */
                }
                button {
                    padding: 0.9rem;
                    font-size: 1rem;
                    width: 100%; /* Full width buttons */
                }
                 button[data-action="pause"], button[data-action="play"] {
                    grid-column: auto;
                    order: -1;
                }
            }

            /* Styles for the Search Modal */
            .modal { 
                position: fixed; 
                top:0; 
                left:0; 
                width:100%; 
                height:100%;
                background: rgba(0,0,0,0.5); 
                display:flex; 
                align-items:center;
                justify-content:center; 
                z-index: 2000; /* Ensure it's above other elements */
            }
            .hidden { 
                display:none; 
            }
            .modal-content { 
                background:#23272e; 
                padding:20px; 
                border-radius:12px; 
                width:90%; /* Responsive width */
                max-width:400px; /* Max width for larger screens */
                color:#e0e0e0; 
                font-family:"Segoe UI", Tahoma, Geneva, Verdana, sans-serif; 
                position: relative; /* For the close button positioning */
            }
            .modal-content h2 {
                margin-top: 0;
                color: #00ffd5; /* Accent color for heading */
            }
            .modal-content input { 
                width: calc(100% - 16px); /* Account for padding */
                padding:8px; 
                margin:8px 0; 
                border-radius:6px; 
                border:1px solid #444; /* Subtle border */
                background: #333; /* Darker input background */
                color: #e0e0e0;
            }
            .modal-content button { 
                padding:10px 15px; /* Slightly larger buttons */
                border:none; 
                border-radius:6px;
                background:#00ffd5; /* Accent color for button */
                color:#23272e; 
                cursor:pointer; 
                font-weight: bold;
                transition: background 0.3s ease;
            }
            .modal-content button:hover {
                background: #00e6bf; /* Slightly darker on hover */
            }
            .modal-content ul { 
                list-style:none; 
                padding:0; 
                max-height:200px; 
                overflow-y:auto; 
                border: 1px solid #555; /* Border for results list */
                border-radius: 6px;
                margin-top: 15px;
            }
            .modal-content li { 
                padding:10px; /* More padding for list items */
                border-bottom:1px solid #444; 
                cursor:pointer; 
                text-align: left; /* Align text to left */
            }
            .modal-content li:last-child {
                border-bottom: none; /* No border on last item */
            }
            .modal-content li:hover { 
                background:#2c313a; 
            }
            .close { 
                position: absolute; /* Position relative to modal-content */
                top: 10px;
                right: 15px;
                cursor:pointer; 
                font-size:24px; /* Larger close button */
                color: #aaa;
            }
            .close:hover {
                color: #fff;
            }

            @media (max-width: 600px) {
                #spacing-element {
                    height: 5em; /* Reduced spacing on smaller screens */
                }
            }
        </style>
    </head>
    <body>
        <div class="container">
            <div id="spacing-element" style="width: 100%;"></div>
            <h1>Now Playing</h1>
            <div id="song-title" class="song-title">Loading...</div>
            <div id="volume-display" class="volume-display">Volume: --</div>
            <div id="song-position" class="song-position"></div>
            <br>
            <div class="buttons">
                <button onclick="sendAction('previous')">‚èÆ Previous</button>
                <button id="play-pause-button" data-action="pause" onclick="sendAction(this.dataset.action)">‚è∏ Pause</button>
                <button onclick="sendAction('skip')">‚è≠ Skip</button>
                <button onclick="sendAction('volume_down')">üîâ Volume -</button>
                <button onclick="sendAction('volume_up')">üîä Volume +</button>
                <button id="repeat-button" onclick="sendAction('repeat')">üîÅ Repeat</button>
            </div>
        </div>

        <div id="settings-modal" style="display:none;position:fixed;top:0;left:0;width:100vw;height:100vh;background:rgba(0,0,0,0.5);justify-content:center;align-items:center;z-index:2000;">
            <form id="theme-form" style="
                background: var(--secondary, #203a43);
                color: var(--text, #fff);
                padding: 2rem 2.5rem;
                border-radius: 18px;
                box-shadow: 0 8px 32px rgba(0,0,0,0.4);
                min-width: 300px;
                display: flex;
                flex-direction: column;
                gap: 1.1rem;
                position: relative;
            ">
                <h2 style="margin:0 0 1rem 0;">Theme Settings</h2>
                <label>Primary Color <input type="color" id="theme-primary" /></label>
                <label>Secondary Color <input type="color" id="theme-secondary" /></label>
                <label>Accent Color <input type="color" id="theme-accent" /></label>
                <label>Danger Color <input type="color" id="theme-danger" /></label>
                <label>Text Color <input type="color" id="theme-text" /></label>
                <div style="display:flex; gap:0.7rem; margin-top:1rem;">
                    <button type="submit" style="flex:1; background:var(--accent,#1abc9c);color:var(--text,#fff);border:none;border-radius:8px;padding:0.7rem 0;">Save</button>
                    <button type="button" onclick="document.getElementById('settings-modal').style.display = 'none';" style="flex:1; background:var(--danger,#e74c3c);color:var(--text,#fff);border:none;border-radius:8px;padding:0.7rem 0;">Cancel</button>
                    <button type="button" id="resetThemeButton" style="flex:1; background:#6c757d; color:var(--text,#fff); border:none; border-radius:8px; padding:0.7rem 0;">Reset to Default</button>
                </div>
                <div style="margin-top:2rem;display:flex;align-items:center;gap:0.7rem;">
                    <input type="checkbox" id="play-on-device" style="transform:scale(1.3);" />
                    <label for="play-on-device" style="font-size:1.1rem;cursor:pointer;">Play On Device</label>
                </div>
            </form>
        </div>

        <div id="audio-status" style="position: fixed; bottom: 10px; left: 10px; background: rgba(0,0,0,0.7); color: white; padding: 8px 12px; border-radius: 5px; font-size: 0.9em; z-index: 2001; max-width: 90vw; word-wrap: break-word;">Audio: Initializing...</div>

        <button id="openSettingsButton" onclick="openSettings()" style="position: fixed; top: 20px; right: 30px; z-index: 1000; background: var(--accent, #1abc9c); color: var(--text, #fff); border: none; outline: none; border-radius: 50px; padding: 0.7rem 1.2rem; font-size: 1.1rem; cursor: pointer;">‚öôÔ∏è Theme Settings</button>

        <button id="openSearchButton" style="position: fixed; top: 70px; right: 30px; z-index: 1000; background: var(--accent, #1abc9c); color: var(--text, #fff); border: none; outline: none; border-radius: 50px; padding: 0.7rem 1.2rem; font-size: 1.1rem; cursor: pointer;">üîç Search Song</button>


        <div id="searchModal" class="modal hidden">
            <div class="modal-content">
                <span class="close" id="closeSearch">&times;</span>
                <h2>Search for a Song</h2>
                <input type="text" id="searchQuery" placeholder="Enter song name...">
                <button id="searchButton">Search</button>
                <ul id="searchResults"></ul>
            </div>
        </div>


        <script>
            // --- Theme Management ---
            const DEFAULT_THEME = {
                name: "Cool Dark Mode",
                primary: "#1A2B34",
                secondary: "#101C24",
                accent: "#AbAb00",
                danger: "#EF5350",
                text: "#E0E0E0",
                background: "linear-gradient(135deg, #0D1B2A, #1B263B, #0F1D2F)"
            };

            function getTheme() {
                const saved = localStorage.getItem('musicapp_theme');
                try {
                    if (!saved) return DEFAULT_THEME;
                    if (typeof saved === "string" && saved.trim().startsWith("{")) {
                        return JSON.parse(saved);
                    } else {
                        localStorage.removeItem('musicapp_theme');
                        return DEFAULT_THEME;
                    }
                } catch (e) {
                    localStorage.removeItem('musicapp_theme');
                    return DEFAULT_THEME;
                }
            }

            function applyTheme(theme) {
                document.documentElement.style.setProperty('--primary', theme.primary || DEFAULT_THEME.primary);
                document.documentElement.style.setProperty('--secondary', theme.secondary || DEFAULT_THEME.secondary);
                document.documentElement.style.setProperty('--accent', theme.accent || DEFAULT_THEME.accent);
                document.documentElement.style.setProperty('--danger', theme.danger || DEFAULT_THEME.danger);
                document.documentElement.style.setProperty('--text', theme.text || DEFAULT_THEME.text);
                document.body.style.background = theme.background || DEFAULT_THEME.background;
                document.body.style.color = theme.text || DEFAULT_THEME.text;
            }

            function saveTheme(theme) {
                try {
                    localStorage.setItem('musicapp_theme', JSON.stringify(theme));
                } catch (e) {
                    console.error("Error saving theme to localStorage:", e);
                }
            }

            // --- Global Audio Variables ---
            let audio = null;
            let currentSongUrl = null;
            let lastSongTitle = null;
            let positionUpdater = null;

            // --- Audio Status Update Function ---
            function updateAudioStatus(message) {
                const statusEl = document.getElementById('audio-status');
                if (statusEl) {
                    statusEl.textContent = "Audio: " + message;
                }
                console.log("Audio Status:", message);
            }

            // --- Helper to format time ---
            function formatTime(seconds) {
                const m = Math.floor(seconds / 60);
                const s = Math.floor(seconds % 60);
                return `${m}:${s.toString().padStart(2, '0')}`;
            }

            // --- Real-time position updater for browser audio ---
            function startPositionUpdater() {
                if (positionUpdater) return;
                const posEl = document.getElementById('song-position');
                function update() {
                    if (audio && !audio.paused && !audio.ended) {
                        posEl.textContent = formatTime(audio.currentTime);
                        positionUpdater = requestAnimationFrame(update);
                    } else {
                        positionUpdater = null;
                    }
                }
                update();
            }
            function stopPositionUpdater() {
                if (positionUpdater) {
                    cancelAnimationFrame(positionUpdater);
                    positionUpdater = null;
                }
            }

            document.addEventListener('DOMContentLoaded', () => {
                function getThemeWithFallback() {
                    try {
                        const saved = localStorage.getItem('musicapp_theme');
                        if (!saved || saved === "[object Object]") return DEFAULT_THEME;
                        return JSON.parse(saved);
                    } catch (e) {
                        console.error("Error loading theme from localStorage, falling back to default:", e);
                        return DEFAULT_THEME;
                    }
                }

                function applyThemeOnLoad() {
                    const theme = getThemeWithFallback();
                    if (!theme.text) theme.text = DEFAULT_THEME.text;
                    if (theme.text === "#fff") theme.text = "#ffffff";
                    applyTheme(theme);

                    document.getElementById('theme-primary').value = theme.primary || DEFAULT_THEME.primary;
                    document.getElementById('theme-secondary').value = theme.secondary || DEFAULT_THEME.secondary;
                    document.getElementById('theme-accent').value = theme.accent || DEFAULT_THEME.accent;
                    document.getElementById('theme-danger').value = theme.danger || DEFAULT_THEME.danger;
                    document.getElementById('theme-text').value = theme.text && theme.text.startsWith('#') ? (theme.text === "#fff" ? "#ffffff" : theme.text) : (DEFAULT_THEME.text.startsWith('#') ? (DEFAULT_THEME.text === "#fff" ? "#ffffff" : DEFAULT_THEME.text) : '#ffffff');
                }
                applyThemeOnLoad();

                // Make openSettings available globally for onclick in HTML
                window.openSettings = function() {
                    const theme = getTheme();
                    document.getElementById('theme-primary').value = theme.primary || DEFAULT_THEME.primary;
                    document.getElementById('theme-secondary').value = theme.secondary || DEFAULT_THEME.secondary;
                    document.getElementById('theme-accent').value = theme.accent || DEFAULT_THEME.accent;
                    document.getElementById('theme-danger').value = theme.danger || DEFAULT_THEME.danger;
                    document.getElementById('theme-text').value = theme.text || DEFAULT_THEME.text;
                    document.getElementById('settings-modal').style.display = 'flex';
                }
                window.closeSettings = function() {
                    document.getElementById('settings-modal').style.display = 'none';
                }

                function handleThemeSave(e) {
                    e.preventDefault();
                    const theme = getTheme();
                    theme.primary = document.getElementById('theme-primary').value;
                    theme.secondary = document.getElementById('theme-secondary').value;
                    theme.accent = document.getElementById('theme-accent').value;
                    theme.danger = document.getElementById('theme-danger').value;
                    theme.text = document.getElementById('theme-text').value;
                    saveTheme(theme);
                    applyTheme(theme);
                    closeSettings();
                }
                document.getElementById('theme-form').onsubmit = handleThemeSave;

                // --- Reset to Default Theme Functionality ---
                window.resetToDefaultTheme = function() {
                    saveTheme(DEFAULT_THEME); // Save the default theme to local storage
                    applyTheme(DEFAULT_THEME); // Apply it instantly to the page

                    // Update the color inputs in the modal to reflect the default values
                    document.getElementById('theme-primary').value = DEFAULT_THEME.primary;
                    document.getElementById('theme-secondary').value = DEFAULT_THEME.secondary;
                    document.getElementById('theme-accent').value = DEFAULT_THEME.accent;
                    document.getElementById('theme-danger').value = DEFAULT_THEME.danger;
                    document.getElementById('theme-text').value = DEFAULT_THEME.text;

                    closeSettings(); // Close the modal after resetting
                    // Optional: You could add a small alert or temporary message for user feedback
                    // alert('Theme reset to default!'); 
                }

                // Attach event listener for the new reset button
                document.getElementById('resetThemeButton').addEventListener('click', window.resetToDefaultTheme);

                // --- Play On Device Logic ---
                function getPlayOnDevice() {
                    return localStorage.getItem('play_on_device') === 'true';
                }
                function setPlayOnDevice(val) {
                    localStorage.setItem('play_on_device', val ? 'true' : 'false');
                    if (val && audio && audio.src && audio.paused) {
                        audio.play().then(() => updateAudioStatus("Playback resumed on device.")).catch(e => {
                            updateAudioStatus(`Auto-play failed after enabling device playback: ${e.message}.`);
                            console.error("Auto-play failed:", e);
                        });
                    } else if (!val && audio && !audio.paused) {
                        audio.pause();
                        updateAudioStatus("Playback on device stopped (disabled via checkbox).");
                    }
                }

                const playOnDeviceCheckbox = document.getElementById('play-on-device');
                playOnDeviceCheckbox.checked = getPlayOnDevice();
                playOnDeviceCheckbox.onchange = function() {
                    setPlayOnDevice(this.checked);
                };

                // --- Audio Sync Logic ---
                async function fetchSongUrl() {
                    return "/song";
                }

                async function syncAudio(data) {
                    // data: { title, position, paused, repeat, volume }
                    const playOnDeviceEnabled = getPlayOnDevice();
                    if (!playOnDeviceEnabled) {
                        if (audio && !audio.paused) audio.pause();
                        stopPositionUpdater();
                        return;
                    }

                    // 1. Ensure audio element exists
                    if (!audio) {
                        audio = new Audio();
                        audio.style.display = "none";
                        audio.preload = "auto";
                        document.body.appendChild(audio);
                        updateAudioStatus("Audio element created.");

                        audio.onended = function() { updateAudioStatus("Song ended."); };
                        audio.onerror = function() { updateAudioStatus(`Error loading/playing audio: ${audio.error?.message || 'Unknown error'}`); };
                        audio.onpause = function() { if (getPlayOnDevice()) updateAudioStatus("Paused."); stopPositionUpdater(); };
                        audio.onplaying = function() { if (getPlayOnDevice()) updateAudioStatus("Playing."); startPositionUpdater(); };
                        audio.onloadeddata = function() { updateAudioStatus("Audio data loaded."); };
                        audio.onstalled = function() { updateAudioStatus("Playback stalled (network issue?)."); };
                        audio.onsuspend = function() { updateAudioStatus("Audio loading suspended by browser."); };
                    }

                    // 2. Check and set song source
                    const songUrlToPlay = await fetchSongUrl();

                    // Reload audio if the song title changes
                    if (lastSongTitle !== data.title) {
                        updateAudioStatus(`Song changed: ${data.title}. Reloading audio...`);
                        audio.src = songUrlToPlay + "?t=" + Date.now();
                        audio.load();
                        lastSongTitle = data.title;
                    }

                    // 3. Sync properties
                    audio.volume = typeof data.volume === "number" ? Math.max(0, Math.min(1, data.volume)) : 1.0;
                    audio.loop = !!data.repeat;

                    // 4. Sync play/pause state and currentTime
                    let targetTime = data.position || 0;
                    if (audio.readyState >= HTMLMediaElement.HAVE_METADATA) {
                        if (isFinite(targetTime) && targetTime >= 0 && targetTime < audio.duration) {
                            if (Math.abs(audio.currentTime - targetTime) > 1.0) {
                                audio.currentTime = targetTime;
                            }
                        }
                    }

                    if (data.paused) {
                        if (!audio.paused) audio.pause();
                        stopPositionUpdater();
                    } else {
                        if (audio.paused && audio.readyState >= HTMLMediaElement.HAVE_ENOUGH_DATA) {
                            audio.play().then(() => startPositionUpdater()).catch(error => {
                                updateAudioStatus(`Play failed: ${error.message}. User interaction may be needed.`);
                                console.error("Error playing audio:", error);
                            });
                        } else {
                            startPositionUpdater();
                        }
                    }
                }

                // --- CSS Variables for Theme (already defined in style block at top, no need to inject dynamically) ---
                // The dynamic style injection for CSS variables was for a previous version of the code
                // where the theme variables were not applied directly to body/documentElement in the initial CSS.
                // Since they are now, this dynamic injection is redundant.
                // const style = document.createElement('style');
                // style.innerHTML = [ /* ... content ... */ ].join('\n');
                // document.head.appendChild(style);

                // --- Existing App Logic ---
                // --- TitleCleaner Class (REWRITTEN TO MATCH PYTHON LOGIC) ---
                class TitleCleaner {
                    // Regex pattern for splitting track titles.
                    _splitPattern = /(?: - |\(|\||\[)/;

                    // Default search and replace rules for cleaning.
                    // Each rule is [old_pattern, new_replacement]
                    _defaults = [
                        ["***[]*Paused", " -[Paused]-"],
                        ["*=*", " -[Paused]-"],
                        ["*+*", " -[Repeat]-"]
                    ];

                    constructor(rules = null) {
                        this.rules = rules || this._defaults;
                    }

                    /**
                    * Cleans a raw song title string to extract and format artist and track.
                    * Handles various formats including:
                    * - Artist - Track
                    * - Track Only
                    * - Artist - Track - Artist (where start and end artists are the same)
                    * - Context - Artist - Track (attempts to identify actual artist and track)
                    * - Strips suffixes and applies general string replacements.
                    * @param {string} raw The raw song title string.
                    * @returns {string} The cleaned song title.
                    */
                    clean(raw, rmode = false) {
                        if (typeof raw !== 'string') {
                            return ""; // Return empty string for non-string input
                        }

                        let coreText = raw.trim();
                        let suffixToStrip = "";

                        // 1. Detect and strip suffix based on rules.
                        // Finds the first rule where rawText ends with the rule's old_pattern.
                        for (const [oldPattern, _] of this.rules) {
                            if (coreText.endsWith(oldPattern)) {
                                suffixToStrip = oldPattern;
                                break; // Found the first matching suffix as per original logic
                            }
                        }

                        if (suffixToStrip) {
                            // Slice to remove the suffix from coreText
                            coreText = coreText.slice(0, -suffixToStrip.length).trim();
                        }

                        // 2. Determine Artist and Track from the `coreText`
                        let finalArtist = "";
                        let finalTrack = "";

                        // Split `coreText` by " - " delimiter, filter out empty parts
                        const splitPattern = rmode ? ' - ' : '![]!';
                        const parts = coreText.split(splitPattern).map(p => p.trim()).filter(p => p);

                        if (!parts.length) {
                            // coreText was empty or became empty after stripping suffix
                            // finalArtist and finalTrack remain empty
                        } else if (parts.length === 1) {
                            // Only one segment, assume it's the track
                            finalTrack = parts[0];
                        } else if (parts.length === 2) {
                            // Standard "Artist - Track"
                            finalArtist = parts[0];
                            finalTrack = parts[1];
                        } else if (parts.length > 2) {
                            // More than two parts, e.g., "A - B - C", "A - B - C - D"
                            // Case 1: "Artist - Title - Artist" (ends are the same, case-insensitive)
                            if (parts[0].toLowerCase() === parts[parts.length - 1].toLowerCase()) {
                                finalArtist = parts[0];
                                finalTrack = parts.slice(1, -1).join(' - '); // Join all middle parts as track
                            }
                            // Case 2: Specifically three parts "X - Y - Z" where X != Z
                            // Assumes "Context - Actual Artist - Actual Track"
                            else if (parts.length === 3) {
                                finalArtist = parts[1]; // Y is the artist
                                finalTrack = parts[2];  // Z is the track
                            } else {
                                // Fallback for len(parts) > 3 and not (A - ... - A)
                                // Default to: first part is artist, rest is track
                                finalArtist = parts[0];
                                finalTrack = parts.slice(1).join(' - ');
                            }
                        }

                        // 3. Isolate main track title from `finalTrack` using `_splitPattern`
                        // This pattern is intended to remove things like "(feat. XYZ)", "[Remix]", etc.
                        // from the end or middle of the track title.
                        let mainTitle = "";
                        if (finalTrack) {
                            // `split` with limit 1 gets the content before the first match.
                            // [0] ensures we get the part before the separator.
                            const mainTitleCandidate = finalTrack.split(this._splitPattern, 1)[0].trim();
                            
                            if (!mainTitleCandidate && finalTrack) {
                                // This happens if finalTrack itself is or starts with the pattern,
                                // e.g., track is "(Interlude)" and pattern matches it.
                                // In such cases, the finalTrack (as is) should be the mainTitle.
                                mainTitle = finalTrack;
                            } else {
                                mainTitle = mainTitleCandidate;
                            }
                        }

                        // 4. Construct the cleaned core string (artist - title)
                        const cleanedCoreParts = [];
                        if (finalArtist.trim()) {
                            cleanedCoreParts.push(finalArtist.trim());
                        }
                        if (mainTitle.trim()) {
                            cleanedCoreParts.push(mainTitle.trim());
                        }
                        
                        let cleanedIntermediateResult = cleanedCoreParts.join(" - ");

                        // 5. Reattach the original suffix
                        let resultWithSuffix = cleanedIntermediateResult;
                        if (cleanedIntermediateResult || suffixToStrip) { // Only add suffix if there's core content or a suffix existed
                            resultWithSuffix = `${cleanedIntermediateResult}${suffixToStrip}`;
                        }
                        if (!cleanedIntermediateResult && !suffixToStrip) { // Both were empty
                            resultWithSuffix = "";
                        }


                        // 6. Apply all general replacement rules from `self.rules`
                        // Ensure oldPattern is escaped for RegExp if it contains special characters
                        let finalCleanedStr = resultWithSuffix;
                        for (const [oldPattern, newReplacement] of this.rules) {
                            // Escape special characters in oldPattern for use in RegExp constructor
                            const safeOldPattern = oldPattern.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                            // Use global flag 'g' to replace all occurrences, mimicking Python's str.replace
                            finalCleanedStr = finalCleanedStr.replace(new RegExp(safeOldPattern, 'g'), newReplacement);
                        }
                        
                        return finalCleanedStr.trim(); // Final strip for good measure
                    }
                }

                const cleaner = new TitleCleaner();

                async function sendAction(action) {
                    try {
                        if (action === 'pause' || action === 'play') {
                            const playPauseButton = document.getElementById('play-pause-button');
                            if (action === 'pause') {
                                playPauseButton.dataset.action = 'play';
                                playPauseButton.textContent = '‚ñ∂ Play';
                            } else {
                                playPauseButton.dataset.action = 'pause';
                                playPauseButton.textContent = '‚è∏ Pause';
                            }
                        }
                        const response = await fetch('/action', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({ action })
                        });
                        const result = await response.json();
                        if (result.code === 'success') {
                            window.updateSongState(result);
                        } else {
                            console.error('Action failed:', result.message);
                            document.getElementById('song-title').textContent = 'Error: ' + result.message;
                            updateAudioStatus(`Action '${action}' failed: ${result.message}`);
                        }
                    } catch (error) {
                        console.error('Error sending action:', error);
                        document.getElementById('song-title').textContent = 'Error communicating with server.';
                        updateAudioStatus(`Error sending action '${action}': ${error.message}`);
                    }
                }
                window.sendAction = sendAction;

                async function pollStatus() {
                    try {
                        const startTime = performance.now();
                        const res = await fetch('/action', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ action: 'status' })
                        });
                        const endTime = performance.now();
                        const latency = (endTime - startTime) / 1000; // in seconds

                        const data = await res.json();
                        if (data.code === 'success') {
                            // Attach latency to data for use in updateSongState
                            data._latency = latency;
                            window.updateSongState(data);
                        } else {
                            console.error('Status poll failed:', data.message);
                            updateAudioStatus(`Status poll failed: ${data.message}`);
                        }
                    } catch (error) {
                        console.error('Error polling status:', error);
                        updateAudioStatus(`Error polling status: ${error.message}`);
                    }
                }

                window.updateSongState = function(data) {
                    // data: { title, position, paused, repeat, volume }
                    const songEl = document.getElementById('song-title');
                    const volEl = document.getElementById('volume-display');
                    const playPauseButton = document.getElementById('play-pause-button');
                    const repeatButton = document.getElementById('repeat-button');
                    const posEl = document.getElementById('song-position');

                    // Clean and display the title
                    let display = `üéµ ${cleaner.clean(data.title || '')}`;

                    // Always remove [Repeat] and -[Paused]- first
                    display = display.replace(/\s*\[Repeat\]/, '');
                    display = display.replace(/\s*-\[Paused\]-/, '');

                    songEl.classList.remove('paused', 'repeat-active');
                    if (repeatButton) repeatButton.classList.remove('repeat-active');

                    // Add -[Paused]- if paused
                    if (data.paused) {
                        songEl.classList.add('paused');
                        playPauseButton.dataset.action = 'play';
                        playPauseButton.textContent = '‚ñ∂ Play';
                        display = display.replace(/\s*$/, '') + ' -[Paused]-';
                    } else {
                        playPauseButton.dataset.action = 'pause';
                        playPauseButton.textContent = '‚è∏ Pause';
                    }

                    // Add [Repeat] if repeat is on
                    if (data.repeat) {
                        songEl.classList.add('repeat-active');
                        if (repeatButton) repeatButton.classList.add('repeat-active');
                        display = display.replace(/\s*$/, '') + ' [Repeat]';
                    }

                    songEl.innerHTML = display;
                    
                    let latency = data._latency || 0;
                    let adjustedPosition = (typeof data.position === "number" && !isNaN(data.position))
                        ? data.position + latency / 2
                        : 0;

                    if (getPlayOnDevice() && audio && !audio.paused && !audio.ended) {
                        startPositionUpdater();
                    } else {
                        posEl.textContent = formatTime(adjustedPosition);
                        stopPositionUpdater();
                    }

                    volEl.textContent = "Volume: " + Math.round((data.volume || 0) * 100) + "%";

                    // Sync audio (if you use play-on-device)
                    if (typeof syncAudio === "function") {
                        syncAudio(data);
                    }
                };

                // Initial poll and interval
                pollStatus();
                setInterval(pollStatus, 1000);

                // --- Search Functionality Scripts ---
                const openSearchButton = document.getElementById('openSearchButton');
                const searchModal = document.getElementById('searchModal');
                const closeSearchButton = document.getElementById('closeSearch');
                const searchQueryInput = document.getElementById('searchQuery');
                const searchButton = document.getElementById('searchButton');
                const searchResultsList = document.getElementById('searchResults');

                openSearchButton.addEventListener('click', () => {
                    searchModal.classList.remove('hidden');
                    searchQueryInput.focus(); // Focus on the input when modal opens
                });

                closeSearchButton.addEventListener('click', () => {
                    searchModal.classList.add('hidden');
                    searchResultsList.innerHTML = ''; // Clear results when closing
                    searchQueryInput.value = ''; // Clear search query
                });

                // Close modal if clicked outside modal-content (optional, but good UX)
                searchModal.addEventListener('click', (e) => {
                    if (e.target === searchModal) {
                        searchModal.classList.add('hidden');
                        searchResultsList.innerHTML = '';
                        searchQueryInput.value = '';
                    }
                });

                searchButton.addEventListener('click', () => {
                    const query = searchQueryInput.value.trim();
                    if (!query) {
                        searchResultsList.innerHTML = '<li>Please enter a search query.</li>';
                        return;
                    }

                    searchResultsList.innerHTML = '<li>Searching...</li>'; // Indicate loading

                    fetch('/search', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ query })
                    })
                    .then(res => res.json())
                    .then(data => {
                        console.log('Search results:', data);
                        searchResultsList.innerHTML = ''; // Clear previous loading/results
                        if (data.results && data.results.length) {
                            data.results.forEach(item => {
                                const li = document.createElement('li');
                                li.textContent = cleaner.clean(item.title || '', true);
                                li.addEventListener('click', () => {
                                    // Play selected song
                                    fetch('/action', {
                                        method: 'POST',
                                        headers: { 'Content-Type': 'application/json' },
                                        body: JSON.stringify({ action: 'play_search', path: item.path })
                                    }).then(() => {
                                        searchModal.classList.add('hidden'); // Close modal on song selection
                                        searchResultsList.innerHTML = ''; // Clear results
                                        searchQueryInput.value = ''; // Clear query
                                    }).catch(error => {
                                        console.error('Error playing searched song:', error);
                                        searchResultsList.innerHTML = `<li>Error playing song: ${error.message}</li>`;
                                    });
                                });
                                searchResultsList.appendChild(li);
                            });
                        } else {
                            const li = document.createElement('li');
                            li.textContent = 'No results found.';
                            searchResultsList.appendChild(li);
                        }
                    })
                    .catch(error => {
                        console.error('Error performing search:', error);
                        searchResultsList.innerHTML = `<li>Error searching: ${error.message}</li>`;
                    });
                });
            });
        </script>
    </body>
</html>